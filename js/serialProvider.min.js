/*!
 * GaonSoft Web Serail Provider Lib v1.7
 * date        : 2023-07-04
 * modify      : 2023-07-05
 * Description : 데모 참조
 * bugfix_1.0  : port read stream 을 라인 단위로 잘라 callback 으로 넘겨 줘야하는데 불특정하게 
 *              stream flush 가 일어나 라인을 구분하기 위해 사용자가 입력해주는 splitChar 추가
 * update_1.1  : splitChar 추가시 옵션형으로 removeSplitChar 넣으면 splitChar를 자동으로 제거
 * update_1.2  : debug 활성화시 buffer 내용도 함께 출력
 * update_1.3  : 재연결 프로세스를 디바이스가 연결 끊기는 시점이 아니라 연결이 끊기고 다시 연결된 시점부터 재연결 시도
 * update_1.4  : 디버그 비활성화시 텍스트 디코딩 로그의 성능저하를 막기위해 콜백 지원으로 변경
 * bugfix_1.5  : DisConnection 함수 호출시 연결이 되어있지 않은 상태의 null 체크를 하지 않아 오류 수정
 * bugfix_1.6  : 한번도 연결되지 않은 상황에서 재연결 시도 로직 제거
 *               Serial 포트 설정을 개발자가 잘못 설정했을시 콘솔에 에러 표시 및 에러 errorMessage 콜백 추가
 *               포트 설정 변경에대한 ConfigSerial 함수 추가
*                removeSplitChar 삭제 옵션 버그 수정
 */ class SerialProvider{constructor(e){let t=this,r=!1,i=!1,a,o,n,l,s,d=[],c={},p=()=>{(s=e.splitChar)&&("string"==typeof s?s=new TextEncoder().encode(s):"number"==typeof s&&(s=[s]))};this.on=(e,t)=>(c[e]||(c[e]=[]),c[e].push(t),this);let h=(t,r)=>{if(c[t])for(let i in c[t])c[t][i](r);e[t]?.(r)},f=()=>{r&&!i&&(i=!0,setTimeout(()=>{w("SerialProvider:reconnecting..."),t.Connection(),i=!1},e.reconnect_interval||3e3))},u=()=>{let t=new Uint8Array(d);for(h("readedStream",{text:e.removeSplitChar?new TextDecoder().decode(t).replaceAll(e.splitChar,""):new TextDecoder().decode(t),buffer:t});d.length>0;)d.pop()},v=async()=>{for(;a.readable&&r;){n=a.readable.getReader();try{for(;r;){let{value:e,done:t}=await n.read();if(t)break;e.forEach(e=>d.push(e)),w(()=>`SerialProvider:push buffer : ${new TextDecoder().decode(new Uint8Array(d))}`),s?s.every(e=>d.includes(e))&&(u(d),w("SerialProvider:read end")):(u(d),w("SerialProvider:read end"))}}catch(i){C(i)}finally{n.releaseLock(),w("SerialProvider:releaseLock")}}await a.close(),w("SerialProvider:port close")};this.ConfigSerial=async t=>{for(void 0!=t.debug&&e.debug!=t.debug&&(e.debug=t.debug),e.baudRate=t?.baudRate||e.baudRate,e.dataBits=t?.dataBits||e.dataBits,e.stopBits=t?.stopBits||e.stopBits,e.parity=t?.parity||e.parity,e.flowControl=t?.flowControl||e.flowControl,t?.splitChar&&(e.splitChar=t.splitChar,p()),await this.DisConnection(),this.Connection(),e.reconnect_interval=t?.reconnect_interval||e.reconnect_interval,e.removeSplitChar=t?.removeSplitChar||e.removeSplitChar;d.length>0;)d.pop()},this.Connection=async()=>{if(!("serial"in navigator))throw"not surported serial. check https";if(l)return l;try{a||(a=await navigator.serial.requestPort({filters:e.filter}));try{await a.open({baudRate:e.baudRate||9600,dataBits:e.dataBits||8,stopBits:e.stopBits||1,parity:e.parity||"none",flowControl:e.flowControl||"none"})}catch(t){return C(t),!1}return r=!0,l=v(),o=a.getInfo(),h("connected",o),w("SerialProvider:connected"),l}catch(i){a=n=l=null,f(),w("SerialProvider:requestPort faild!!")}},this.DisConnection=async()=>{r=!1,n?.cancel(),l&&(await l,n=l=null,w("SerialProvider:disconneted"),h("disconneted"))};let C=e=>{console.error(e),h("errorMessage",e)},w=t=>{e.debug&&console.log("string"==typeof t?t:t())};navigator.serial?.addEventListener("connect",e=>{a=e.target,f()}),navigator.serial?.addEventListener("disconnect",e=>{a=n=l=null,h("disconneted")}),p()}}